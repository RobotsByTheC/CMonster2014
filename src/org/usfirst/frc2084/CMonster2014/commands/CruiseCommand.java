/* 
 * Copyright (c) 2014 RobotsByTheC. All rights reserved.
 *
 * Open Source Software - may be modified and shared by FRC teams. The code must
 * be accompanied by the BSD license file in the root directory of the project.
 */
package org.usfirst.frc2084.CMonster2014.commands;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster2014.Robot;

/**
 * An implementation of a cruise control system. Keeps the robot traveling at
 * the speed specified by the drive joystick when this {@link Command} was
 * started.
 */
public class CruiseCommand extends Command {

    private double cruiseSpeed = 0;
    private boolean setButtonPressed = false;

    public CruiseCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    protected void initialize() {
        cruiseSpeed = -Robot.oi.getDriveJoystick().getY();
    }

    protected void execute() {
        Joystick driveJoystick = Robot.oi.getDriveJoystick();
        double joyY = -driveJoystick.getY();

        if (Robot.oi.cruiseSetButton.get()) {
            if (!setButtonPressed) {
                setButtonPressed = true;
                cruiseSpeed = joyY;
            }
        } else {
            if(setButtonPressed) {
                setButtonPressed = false;
            }
        }

        double speed = cruiseSpeed;
        if ((cruiseSpeed > 0 && (joyY > cruiseSpeed))
                || (cruiseSpeed < 0 && (joyY < cruiseSpeed))) {
            speed = joyY;
        }

        Robot.driveSubsystem.getArcadeDriveAlgorithm().arcadeDrive(
                speed,
                driveJoystick.getX()
        );
    }

    protected boolean isFinished() {
        return false;
    }

    protected void end() {
        cruiseSpeed = 0;
        Robot.driveSubsystem.getArcadeDriveAlgorithm().stop();
    }

    protected void interrupted() {
        end();
    }
}
