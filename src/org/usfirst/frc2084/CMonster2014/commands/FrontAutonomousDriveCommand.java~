package org.usfirst.frc2084.CMonster2014.commands;
import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster2014.Robot;
import org.usfirst.frc2084.CMonster2014.RobotMap;
import org.usfirst.frc2084.CMonster2014.TargetTracking;
/**
 *
 */
public class FrontAutonomousDriveCommand extends Command {
    /**
     * The speed to drive at.
     */
    private static final double DRIVING_SPEED = 0.3;
    /**
     * The speed at which the robot should push itself against the wall to
     * maintain a straight path.
     */
    private static final double SIDEWAYS_SPEED = 0.1;
    /**
     * The rate at which the robot should accelerate.
     */
    private static final double SPEED_INCREMENT = 0.05;
    /**
     * The G-Force that the robot threshold at which the robot should stop. This
     * needs to be calibrated.
     */
    private static final double GFORCE_LIMIT = -0.7; //SET ME!!!!
    /**
     * The maximum time this part of autonomous can take before ending
     * automatically. This is to prevent a major problem should the robot not
     * detect when it hits the wall.
     */
    private static final double TIMEOUT = 3;
    private static final double WAIT_FOR_HOT_TIME = 6.0;
    private double gForce = 0.0;
    private double currentSpeed = 0.0;
    private final boolean leftGoal;
    public FrontAutonomousDriveCommand(boolean leftGoal) {
        super(TIMEOUT);
        this.leftGoal = leftGoal;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    // Called just before this Command runs the first time
    protected void initialize() {
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        if (currentSpeed < DRIVING_SPEED) {
            currentSpeed += SPEED_INCREMENT;
        }
        Robot.driveSubsystem.getRobotDrive().mecanumDrive_Cartesian(leftGoal ? -SIDEWAYS_SPEED : SIDEWAYS_SPEED, currentSpeed);
        gForce = RobotMap.driveSubsystemAccelerometer.getAcceleration(ADXL345_I2C.Axes.kX);
    }
    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        boolean notHot = TargetTracking.getState().equals(TargetTracking.State.NOT_HOT);
        return GFORCE_LIMIT < 0 ? gForce < GFORCE_LIMIT : gForce > GFORCE_LIMIT
                && notHot ? DriverStation.getInstance().getMatchTime() >= WAIT_FOR_HOT_TIME : true;
    }
    // Called once after isFinished returns true
    protected void end() {
        Robot.driveSubsystem.getRobotDrive().stopMotor();
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
