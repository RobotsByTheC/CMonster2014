// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc2084.CMonster2014.commands;
import edu.wpi.first.wpilibj.ADXL345_I2C;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc2084.CMonster2014.Robot;
import org.usfirst.frc2084.CMonster2014.RobotMap;
/**
 *
 */
public class SideAutonomousDriveCommand extends Command {
    /**
     * The speed to drive at for the first part of autonomous. The robot should
     * continue at this speed until it has reached {@link #FAST_DRIVE_DISTANCE}.
     */
    private static final double FAST_DRIVING_SPEED = 0.9;
    /**
     * The speed to drive for hitting the wall and turning.
     */
    private static final double SLOW_DRIVING_SPEED = 0.3;
    /**
     * The distance to drive while moving at {@link #FAST_DRIVING_SPEED} in
     * feet.
     */
    private static final double FAST_DRIVE_DISTANCE = 5.0;
    /**
     * The rate at which the robot should accelerate.
     */
    private static final double SPEED_INCREMENT = 0.05;
    /**
     * The G-Force that the robot threshold at which the robot should stop. This
     * needs to be calibrated.
     */
    private static final double GFORCE_LIMIT = -0.7; //SET ME!!!!
    /**
     * The orientation the robot should be in when it hits the wall in degrees.
     */
    private static final double ROTATION_SETPOINT = 90.0;
    /**
     * Maximum time this part of autonomous can take before ending
     * automatically. This is to prevent a major problem should the robot not
     * detect when it hits the wall.
     */
    private static final double TIMEOUT = 4;
    private double gForce = 0.0;
    private double currentSpeed = 0.0;
    private double currentAngle = 0.0;
    private boolean movingFast = true;
    private final boolean leftGoal;
    public SideAutonomousDriveCommand(boolean leftGoal) {
        super(TIMEOUT);
        this.leftGoal = leftGoal;
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSubsystem);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    /**
     * Called just before this {@link Command} runs the first time.
     */
    protected void initialize() {
        RobotMap.driveSubsystemRearRightEncoder.reset();
        Robot.driveSubsystem.getRobotDrive().resetGyro();
    }
    /**
     * Called repeatedly when this {@link Command} is scheduled to run.
     */
    protected void execute() {
        gForce = RobotMap.driveSubsystemAccelerometer.getAcceleration(ADXL345_I2C.Axes.kY);
        double distance = RobotMap.driveSubsystemRearRightEncoder.getDistance();
        if (movingFast) {
            if (distance < FAST_DRIVE_DISTANCE) {
                if (currentSpeed < FAST_DRIVING_SPEED) {
                    currentSpeed += SPEED_INCREMENT;
                }
            } else {
                movingFast = false;
                currentSpeed = SLOW_DRIVING_SPEED;
                currentAngle = leftGoal ? ROTATION_SETPOINT : -ROTATION_SETPOINT;
            }
        }
        Robot.driveSubsystem.getRobotDrive().mecanumDrive_Orientation(0, currentSpeed, currentAngle);
    }
    protected boolean isFinished() {
        return GFORCE_LIMIT < 0 ? gForce < GFORCE_LIMIT : gForce > GFORCE_LIMIT;
    }
    /**
     * Called once after {@link #isFinished()} returns true.
     */
    protected void end() {
        Robot.driveSubsystem.getRobotDrive().stopMotor();
    }
    /**
     * Called when another command which requires one or more of the same
     * subsystems is scheduled to run.
     */
    protected void interrupted() {
    }
}
